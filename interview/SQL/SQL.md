数据库模式
* 外模式/子模式
* 概念模式/模式/逻辑模式
* 内模式/存储模式/物理模式
  
考点:
* 连接
* mysql存储引擎
* 范式
* 索引
* 事务
* 优化
* 隔离级别

## 隔离级别
[SQL事务的四种隔离级别](https://blog.csdn.net/kai161/article/details/39480445)
[什么是SQL隔离级别？四个SQL隔离级别定义介绍](https://www.2cto.com/database/201805/746823.html)

并发问题:
* 更新丢失: 类似于i++问题
* 脏读: A先更新数据, 然后B读, 如果A回滚, 那B读到脏数据
* 不可重复读: B多次读数据的过程中, A更新数据, 那B读到的数据不一致
* 幻读: B对整个表进行修改等操作, 操作完成后才发现A插入了新数据
    * //不可重复读针对update, 幻读针对insert
  
隔离级别:
* 未提交读(read-uncommitted): A更新未提交B就可以读. 
    * 问题: 脏读
* 提交读/不可重复读(read-committed): A更新提交后B可以读. 
    * 问题: 不可重复读
* 可重复读(repeatable read): B只能读到A事务开始之前的数据. 
    * 问题: 幻读
* 可串行化(serializable): 所有的事务必须并行化. 
    * 代价比较大

锁:
* 表锁, 页锁, 行锁:
    * 表锁: 一次性锁整个表
    * 页锁: 一次性锁表中相邻的一组记录
    * 行锁: 一次性锁一行
        |锁|速度|死锁|锁定粒度|并发度|
        |:-:|:-:|:-:|:-:|:-:|
        |表锁|快|无|大|低|
        |页锁|中|有|中|中|
        |行锁|慢|有|小|高|

      
锁协议:
* 两段封锁协议:
    * 阶段:
        1. 增长阶段: 事务只能获得锁, 不能释放锁
        2. 缩减阶段: 在事务第一次释放锁后开始; 事务只能释放锁, 不能获得锁
    * 特点:
        * 保证冲突可串行化
        * 不保证无死锁
* 多粒度封锁协议:
    * 特点: 
        * 保证冲突可串行化
        * 不保证无死锁



连接:
* 左连接: 除了保存所有匹配的数据记录，还保留左表中未匹配的数据记录
* 右连接: 除了保存所有匹配的数据记录，还保留右表中未匹配的数据记录
* 外连接: 除了保存所有匹配的数据记录，还保留两个表中未匹配的数据记录
* 内连接: 只保留两个表中匹配的数据记录
* 自然连接: 要求两个关系表中进行比较的必须是相同的属性列; 重复列会被消除