* jvm是运行时加载的
    * 性能上稍有下降
    * 更灵活

类加载机制的特点:
* 一个类的几个过程一定是有序开始的, 中间可能会穿插着其它类的加载

**类的**初始化时机:
* new 对象, 对应类未初始化时
* 初始化子类, 发现父类未初始化时
    * **对于接口, 只有真正用到父类(如父类的常量)时, 才会初始化父类**
* putstatic, getstatic, invokestatic指令(读写静态域, 调用静态方法)
* 对未初始化的类进行反射调用
* MethodHandler解析结果为Ref_putstatic, Ref_getstatic, Ref_invokestatic时

非初始化时机:
* 被动引用: 通过子类调用父类的静态字段
* 定义以对象类型为组件类型的数组时, 不被初始化
* 以下语句通过常量传播将常量存到了常量池中(没有引用该类, 而是引用其常量池)
    ```
    public class ConstClass{
        public static final String s = "a";
    }
    ```

类加载过程
1. 加载: 获取class文件并读取
2. 连接(验证, 准备, 解析)
    1. 验证
        1. class文件格式验证: 魔数, 版本号等
        2. 元数据验证(语义分析): 检查**继承关系**等方面是否符合Java语义
        3. 字节码验证(数据流和控制流分析): 保证不会出现非法跳转等问题
            * StackMapTable: 记录初始化时操作数栈, 本地变量表应有的状态
                * -XX:-UseSplitVerifier: 关闭stackMapTable验证
                * -XX:+FailOverToOldVerifier: stackMapTable验证失败时, 按传统方法验证
    2. 准备: 把静态变量赋为0, 把静态常量赋为0或者指定值
        * 如果是静态常量, 那赋成指定值
    3. 解析: 把符号引用解析为直接引用, 保存在栈帧
3. 初始化

## 解析
类或者接口解析: A类方法中解析B时 
1. 对于非数组类型, 由A的类加载器去加载B, 可能会触发对B的父亲的加载
    * 找不到父类时抛出NoClassDefFoundError
2. 对于数组类型, 递归解析组件类型
    * 数组类的可见性及关联的类加载器设为与组件类型相同(对于原始类型, 加载器为bootstrap加载器, 并且是public)
3. 检查访问权限(private等), 如果不满足条件, 抛IllegalAccessError

字段解析: A类方法中解析B类的字段field
1. B类中有字段field, 直接返回其直接引用
2. 遍历实现的接口, 从下往上搜索父接口, 直到找到
3. 从下往上搜索父类, 直到找到
4. 检查权限, 没有权限则抛出IllegalAccessError
5. 找不到, 抛NoSuchFieldError

类方法解析: A类的方法中解析B类的C方法:
1. 如果发现符号引用的是个接口, 抛出IncompitableClassChangeError
2. 在B类中找到, 找到则返回
3. 从下往上搜索父类, 直到找到
4. 遍历接口, 从下往上搜索父接口, 直到则抛出AbstractMethodError
5. 如果找到了, 检查访问权限, 不合法则抛出IllegalAccessError
6. 找不到, 抛NoSuchMethod异常

接口方法解析: A类方法中解析B接口的C方法
1. 如果发现符号引用的是个类, 抛IncompitableClassChangeError
2. 在B接口中从下往上查找, 直到找到
3. **不用检查权限, 接口方法都public**
4. 找不到, 抛出NoSuchMethodError
* 解析完后, 实际运行时根据对象的**实例类型**去调用对应的类方法

## 初始化\<cinit\>
\<cinit\>过程:
1. 初始化时要抢**初始化锁**, 保证线程安全, 如果已初始化, 那直接返回(防止递归初始化)
2. 如果父类未经初始化, 递归执行父类的\<cinit\>
3. 如果静态方法未解析, 按其出现顺序来解析静态方法(静态域中可能要调用)
4. 按照域/静态块的出现顺序初始化域/执行静态块

其它:
* \<cinit\>不是必须的, 如果没有静态成员(域, 方法)或者静态块就不用
* jvm会保证\<cinit\>的线程安全
* 某静态域a如果在静态块下面, 该静态块可以写该静态域(空间已分配好), 但不能读

## 分派
Parent sub = new Sub()
* Parent为sub的静态类型, Sub为sub的实际类型

分派过程
1. 静态分派: 根据**参数的静态类型**来选择方法的重载版本
2. 动态分派: 根据**对象的动态类型**来选择方法的重写版本

方法表
* 在**方法区**中为类建立虚方法表, 为接口建立接口方法表
* 方法表用来保存方法的实际入口地址
* 因为java不支持对类的成员方法进行动态更改 (只能新建类), 所以不用考虑方法表的更新问题