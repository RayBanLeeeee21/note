# 进程

进程与线程
* 进程是**拥有资源**的基本单位, 线程是**独立调度**的基本单位
* 一个进程可以拥有多个线程, 线程中只有少量的私有资源, 共享进程的资源

进程状态:
* 运行: 进程运行中
* 就绪: 进程获得了所有所需资源, 只剩处理器
* 阻塞: 进程所需资源还没得到, 或者调用阻塞原语 

多线程模型
* 多对一: 多个ULT对应一个KLT
    * 优点: 不涉及用户态到内核态的切换, 速度快, 效率高
    * 缺点: 
        * 用户需要自己实现复杂的ULT切换
        * 一个ULT被阻塞时, KLT对应的其它ULT也会被阻塞
* 一对一: 一个ULT对应一个KLT
    * 优点: 
        * 调用操作系统提供的接口来实现, 实现方法简单, 用户不用自己负责线程切换
        * 一个ULT阻塞不会造成其它ULT阻塞
    * 缺点:
        * 切换开销大
* 多对多模型:
    * 两种方法的折衷

调度算法
* First Come First Served (FCFS): 效率低
* Short Job First (SJF): 短作业优先
    * 优点: 减少平均等待时间
    * 缺点: 长作业可能会饥饿
* 优先级调度: 根据优先级来优先调度优先级高的作业 
    * 不可剥夺与可剥夺式
    * 静态优先级与动态优先级
* 高响应比调度: (等待时间+要求服务时间)/要求服务时间
    * 等待时间相同时, 短作业的响应比高
    * 要求服务时间相同时, 先到的等待时间长, 响应比高
    * 长作业不会饥饿 
* 时间片轮转算法
    * 时间片较长: 退化成FCFS算法
    * 时间片较短: 切换频繁, 开销大
* 多级反馈队列调度:
    * 时间片长度逐级队列递增
    * 新作业先加入低级队列, 一个时间片内没处理完则加到下一级
    * 只有低级队列的作业执行完, 才执行高级的

进程通信方式
* 共享内存
* 消息传递:
* 管道通信:
    * 如PipedWriter和PipedReader
    * 半双工通信, 实现双工要两个管道

死锁:
* 四个条件
    * 互斥
    * 不可剥夺
    * 请求与保持 
    * 循环等待
* 死锁预防:
    * 破坏四个条件
* 死锁避免
    * 银行家算法
        * e.g.
            * ![](banker.jpg)
            * 在Need中找到一个符合分配条件的, 将资源分配下去, 然后再回收到Available.
            * 不断迭代上一过程, 直到所有分配完
    * 伪代码:
        ```matlab
        function seq = nonDeadLockSeq(Alloc, Need, Avail, pId)
            seq = [];
            while ~isempty(Alloc)

                oldRow = size(Alloc, 1);

                for r = 1:oldRow
                    % 如果能满足该线程的需求
                    if all(Need(r,:)<=Avail)
                        seq = [seq, pId(r)];
                        Avail = Avail + Alloc(r,:);
                        % 去掉已处理的线程对应的信息
                        Alloc = [Alloc(1:r-1, :);Alloc(r+1:end, :)];
                        Need = [Need(1:r-1, :);Need(r+1:end, :)];
                        pId = [pId(1:r-1),pId(r+1:end)];
                        break;
                    end
                end

                if oldRow == size(Alloc, 1)
                    seq = [];
                    break;
                end

            end
        end
        ```
* 死锁检测:
    * 资源分配图: 
        * 找出请求资源能被满足的线程, 把它的请求边与分配边都去掉
        * 迭代这一过程直到找不到能被消除边的线程(死锁), 或者直到把所有边消除掉
* 死锁解除:
    * 资源剥夺
    * 撤销进程