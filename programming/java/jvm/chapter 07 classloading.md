# Chapter 07 虚拟机类加载机制

## 7.1 概述

类加载机制 : 虚拟机把描述类的数据从Class文件**加载到内存**,并对数据进行**校验**, **转换解析**和**初始化**, 最终形成可以被虚拟机直接使用的Java类型
java语言中, 类型的加载, 连接和初始化在**程序运行时**完成

## 7.2 类加载的时机

类的生命周期
1. 加载 
2. 连接
    1. 验证 
    2. 准备 
    3. 解析
3. 初始化 
4. 使用 
5. 卸载
* 类加载过程按部就班地**开始**, 但穿插着**进行**.  

加载时机 : 没有被规定什么时候开始 <c>// 非本书内容</c>
* 隐式加载: 不用代码显式调用加载方法, 由一些条件触发(参考初始化时机)
* 显式加载: 显式调用ClassLoader的loadClass()
  
初始化时机 (以下场景被称为**主动引用**, 其余场景被称为**被动引用**) : 
1. 遇到new, getstatic, putstatic, invokestatic 等字节码
    * 用new实例化对象
    * 读取、设置对象的静态域
    * 调用对象的静态方法
2. 使用java.lang.reflect包进行反射调用时, 发现类没有被初始化
3. 解析父类引用, 发现未加载父类时
4. 主类(如包含main()的类)被初始化
5. (jdk1.7) java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄, 并且句柄所对应的类没有进行过初始化

非初始化时机(被动引用):
1. 通过子类引用父类的静态字段, 不会初始化子类 (对于静态域, 只有直接定义这个字段的类会被初始化)
2. 构造某个类的数组时, 不会触发该类的初始化
3. 常量传播优化 : **常量域在编译阶段会存入调用类的方法区的常量池**, 故常量域所在的类不会被初始化

接口的初始化与类的初始化的区别在于第三种场景 : 子类接口的初始化不必要求父类接口的初始化, 除非真正用的父接口(如接口中的常量域)


## 7.3 类加载的过程 
类加载的全过程 : 加载 验证 准备 解析 初始化

### 7.3.1 加载
加载阶段虚拟机的工作 : 
1. 通过类的全限定名来获取定义类的二进制流 // ClassLoader的findClass方法
    * 二进制流的获取途径很多 
        * ZIP(JAR, EAR, WAR)
        * 网络
        * 运行时生成(java.lang.reflect.Proxy)
        * 其它文件生成(JSP)
        * 数据库读取
        * ...
    * 开发人员可以通过定义自己的类加载器去控制字节流的获取方式(重写loadClass())
2. 将字节流代表的**静态存储结构**转换为方法区的**运行时数据结构**(加载到方法区)
    * 方法区中的数据存储格式由虚拟机实现自行定义
3. 将类抽象成一个java.lang.Class对象保存到内存, 作为方法区对该类的各种数据的访问入口
    * 该java.lang.Class对象并未要求一定要保存在Java堆(HotSpot将其保存在方法区)

数组的加载 :
* **数组不通过类加载器创建, 由java虚拟机创建** 
* 数组类创建过程的规则
    1. 对于引用类型的组件类型 : 递归采用引用类型的加载过程
        * 类加载器: 组件类型的加载器
        * 可见性: 与组件类型一致
    2. 对于非引用类型的组件类型 (如int[]) : 
        * 类加载器: **BoostrapClassLoader**
        * 可见性: 默认为public
 
加载阶段与连接阶段可能有交叉

## 7.3.2 验证

验证: 为了确保Class文件的字节流包含的信息符合虚拟机的要求
1. 文件格式验证 : **保证字节流可以正确地解析并存储在方法区** 
    1. 是否以**魔数**0xCAFEBABE开头
    2. 主, 次**版本号**是否在当前虚拟机处理范围之内
    3. **常量池**的常量中是否有不被支持的常量或者不符合类型的常量
    4. CONSTANT_Utf8_info型是否有不符合**UTF8**编码的数据
    5. Class文件中各部分及文件本身是否有被删除的或附加的其它信息
    6. ...
    * 后续验证阶段都基于**方法区的存储结构**进行
2. 元数据验证(**校验数据类型**) ： 对字节码描述的信息(**类的元数据信息**)进行**语义分析**
    1. 某个类是否有父类(除了java.lang.Object以外都有)
    2. 父类是否不可继承(final修饰)
    3. 如果不是抽象类, 是否实现了父类或接口的所有要求的方法
    4. 类的字段, 方法是否与父类矛盾(继承自final域或方法, 重载后返回类型不同等)
    5. ...
3. 字节码验证(**校验类的方法体**) : 通过数据流和控制流分析, 确定**程序语义**的合法性 
    1. 保证**操作数栈的数据类型**与**指令代码序列**能配合工作(如防止按long类型载入int类型数据等)
    2. 保证**跳转指令**不会跳到方法体以外的字节码指令上
    3. 保证方法体中的**类型转换**的合法性
    4. ...
    * // 如果一个类字节码没有通过字节码验证, 肯定是有问题的; 但如果一个类字节码通过了字节码验证, 则不一定是安全的
    * StackMapTable 属性: 
        * 位于方法体的Code属性
        * 描述了**方法体**的所有**基本块(按照控制流拆分的代码块)**开始时**本地变量表**和**操作栈**应有的状态
        * 采用StackMapTable便不用根据程序推导的校验方式
        * JDK1.7主版本50以后都采用StackMapTable
4. 符号引用验证 (**在解析阶段发生**)

## 7.3.3 准备
准备: 为类变量**分配内存**, 并**设置初始值**
* 仅包括静态变量, 不包括实例变量

## 7.3.4 解析
解析: 将**符号引用**替换为**直接引用**
* 符号引用与直接引用:
    * 符号引用: 可以定位到目标的字面量
    * 直接引用: 内存指针, 偏移量, 句柄等
* 解析时机:
    * 加载时解析
    * 运行时解析: invokedynamic指令只能运行时解析
* 解析对象
    * 类或接口
    * 域
    * 类方法
    * 接口方法
    * 方法类型 
    * 方法句柄 (动态)

类/接口解析: e.g. A类要解析B类
* 规则:
    1. 根据B类的全限定名, 交给A类的类加载器去加载
        1. 如果B类不是数组, 那B类与A类的类加载器关联
        2. 如果B类是数组类, 则要先检查数组组件类型的加载:
            1. 组件类型为引用类型时, 递归检查加载. B类的**类加载器**和**可见性**与组件类型的加载器一致
            2. 组件类型为原始类型时, B类的类加载器为**BootstrapClassLoader**, **可见性**默认public
* 异常:
    * 解析时发现没有访问权限时(如private), 抛出**IllegamAccessError**异常
    * ClassNotFoundException
    * NoClassDefFoundError: 在A类中解析B类的引用时, 如果加载B类时抛出ClassNotFoundException, 那解析过程抛出该异常

域解析规则:
1. 如果类中存在NameAndType与引用相匹配的域, 则返回这个域的直接引用, 否则2
2. 在接口和类中寻找
    1. 由下往上在接口中寻找
    2. 由下往上在父类中寻找, 直到遇到Object
* 有些严格的编译器实现可能会禁止接口与父类中的同名域, 防止歧义(除非本类中已覆写该域)
* 猜想: 由下往上的寻找顺序, 是为了找到最特有的域
* 异常:
    * **IllegamAccessError**
    * NoSuchFieldError

类方法解析 (invokevirtual):
* 规则
    1. 检查引用(#5)在常量池中是否定义为类方法(Methodref), 否则抛**IncomatibleClassChangeError**异常
    2. 如果当前类中找到了匹配的类, 返回类的直接引用
    3. 向上逐级寻找**父类**的类方法, 直到找到并返回, 否则4
    4. 遍历接口列表, 并向上逐级寻找接口的**父接口**的接口方法, 找到则抛出AbstractMethodError, 否则5
    5. 抛出NoSuchMethodError
* 异常:
    * IncompitableClassChangeError
    * AbstractMethodError
    * NoSuchMethodError
    * IllegalAccessError

接口方法解析 (invokeinterface)
* 规则:
    1. 检查引用(#5)是否为接口方法(InterfaceMethodref), 否则抛出IncompatibleClassChangeError
    2. 在当前接口寻找匹配的接口方法
    3. 向上逐级在父接口中寻找匹配的接口, 直到Object类 (查找范围会包括Object类), 直到找到并返回, 否则4
    4. 抛出NoSuchMethodError
* 异常:
    * IncompatibleClassChangeError
    * NoSuchMethodError

### 7.3.5 初始化

\<cinit\>方法:    
* 执行顺序与规则:
    1. 如果有父类, 先调用父类的\<cinit\>方法
    2. 按静态方法的出现顺序解析静态方法
    3. 按静态域/静态块的出现顺序来处理静态域/静态块
* 其它规则:
    * 静态块中可以写后续出现的静态域, 但不能读 (非法前向引用)
        * 猜想: 在类的准备阶段时, 已为静态域分配内存, 故可以直接写
    * jvm保证父类的\<cinit\>方法先于子类的\<cinit\>方法被调用
    * \<cinit\>方法不是必须的, 没有静态块和静态域的类或接口不需要\<cinit\>方法
    * 同步调用, 只能调用一次, 不能被用户调用
    * 处理某个静态域\静态块时, 会判断是否经过初始化, 防止递归初始化
* 接口\<cinit\>规则:
    * 父类的\<cinit\>方法无需在子类之前调用
    

## 7.4 类加载器

类的比较:
* 比较Class类实例时, 即要比较类的全限定名, 也要比较类关联的类加载器
    * instanceof
    * equals()
    * isAssignableFrom()

双亲委派模型:
* 类加载器:
    * BootstrapClassLoader: 加载一些与jvm相关的类, 包括rt.jar的类 
        1. 原始类型数组
        2. Class
        3. Object
        4. String
        5. ...
        * 用户不可见
    * ExtClassLoader: \%JAVA_HOME\%/lib/ext目录或java.ext.dirs指定的
    * AppClassLoader: 加载classpath指定的类
        * 用户定义的类加载器默认继承自AppClassLoader
        * ClassLoader.getSystemClassLoader()返回该类加载器
* 加载机制:
    1. 判断当前类加载器中是否加载该类, 是则返回该类, 否则2
    2. 交双亲类加载器递归加载:
        1. 双亲类加载器加载成功, 则返回双亲类加载器返回的结果 (该类与某个双亲类加载器关联)
        2. 双亲类加载器加载失败, 当前类加载器尝试加载
            1. 加载成功, 则返回结果, 类与当前加载器关联
            2. 加载失败, 抛出ClassNotFoundException异常