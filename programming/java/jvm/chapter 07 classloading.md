# Chapter 07 虚拟机类加载机制

## 7.1 概述

类加载机制 : 虚拟机把描述类的数据从Class文件**加载到内存**,并对数据进行**校验**, **转换解析**和**初始化**, 最终形成可以被虚拟机直接使用的Java类型
java语言中, 类型的加载, 连接和初始化在**程序运行时**完成

## 7.2 类加载的时机

类的生命周期 : 加载 连接(验证 准备 解析) 初始化 使用 卸载
* 类加载过程按部就班地**开始**, 但穿插着**进行**.  
* 
加载时机 : 没有被规定什么时候开始
初始化时机 (以下场景被称为**主动引用**, 其余场景被称为**被动引用**) : 
1. 遇到new, getstatic, putstatic, invokestatic 等字节码
    * 用new实例化对象
    * 读取、设置对象的静态域
    * 调用对象的静态方法
2. 使用java.lang.reflect包进行反射调用时, 发现类没有被初始化
3. 初始化一个类时, 其父类没有被初始化
4. 用户指定的将被执行的(如包含main()的类)会被初始化
5. (jdk1.7) java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄, 并且句柄所对应的类没有进行过初始化
* 被动引用的场景 :
    1. 通过子类引用父类的静态字段, 不会初始化子类 (对于静态域, 只有直接定义这个字段的类会被初始化)
    2. 构造某个类的数组时, 不会触发该类的初始化
    3. 常量传播优化 : **常量域在编译阶段会存入调用类的方法区的常量池**, 故常量域所在的类不会被初始化
接口的初始化与类的初始化的区别在于第三种场景 : 子类接口的初始化不必要求父类接口的初始化, 除非真正用的父接口(如接口中的常量域)

## 7.3 类加载的过程 
类加载的全过程 : 加载 验证 准备 解析 初始化
### 7.3.1 加载
加载阶段虚拟机的工作 : 
1. 通过类的全限定名来获取定义类的二进制流
    * 二进制流的获取途径很多 
        * ZIP(JAR, EAR, WAR)
        * 网络
        * 运行时生成(java.lang.reflect.Proxy)
        * 其它文件生成(JSP)
        * 数据库读取
        * ...
    * 开发人员可以通过定义自己的类加载器去控制字节流的获取方式(重写loadClass())
2. 将字节流代表的**静态存储结构**转换为方法区的**运行时数据结构**(加载到方法区)
    * 方法区中的数据存储格式由虚拟机实现自行定义
3. 将类抽象成一个java.lang.Class对象保存到内存, 所为方法区对该类的各种数据的访问入口
    * 该java.lang.Class对象并未要求一定要保存在Java堆(HotSpot将其保存在方法区)

数组的加载 :
* **数组不通过类加载器创建, 由java虚拟机创建** 
* 数组类创建过程的规则
    1. 对于引用类型的组件类型 : 递归采用引用类型的加载过程
        * 该数组类将在加载该组件类型的类加载器的**类名称空间**被标识
        * 数组类的可见性与组件类型保持一致
    2. 对于非引用类型的组件类型 (如int[]) : 数组类会被标记为与引导类加载关联
        * 数组类的可见性默认为public 
加载阶段与连接阶段可能有交叉

## 7.3.1 验证

验证 : 为了确保Class文件的字节流包含的信息符合虚拟机的要求
验证的阶段 :
1. 文件格式验证 : **保证字节流可以正确地解析并存储在方法区** 
    1. 是否以**魔数**0xCAFEBABE开头
    2. 主, 次**版本号**是否在当前虚拟机处理范围之内
    3. **常量池**的常量中是否有不被支持的常量或者不符合类型的常量
    4. CONSTANT_Utf8_info型是否有不符合**UTF8**编码的数据
    5. Class文件中各部分及文件本身是否有被删除的或附加的其它信息
    6. ...
    * 后续验证阶段都基于**方法区的存储结构**进行
2. 元数据验证(**校验数据类型**) ： 对字节码描述的信息(**类的元数据信息**)进行**语义分析**
    1. 某个类是否有父类(除了java.lang.Object以外都有)
    2. 父类是否不可继承(final修饰)
    3. 如果不是抽象类, 是否实现了父类或接口的所有要求的方法
    4. 类的字段, 方法是否与父类矛盾(继承自final域或方法, 重载后返回类型不同等)
    5. ...
3. 字节码验证(**校验类的方法体**) : 通过数据流和控制流分析, 确定**程序语义**的合法性 
    1. 保证**操作数栈的数据类型**与**指令代码序列**能配合工作(如防止按long类型载入int类型数据等)
    2. 保证**跳转指令**不会跳到方法体以外的字节码指令上
    3. 保证方法体中的**类型转换**的合法性
    4. ...
    * // 如果一个类字节码没有通过字节码验证, 肯定是有问题的; 但如果一个类字节码通过了字节码验证, 则不一定是安全的
    * StackMapTable 属性: 
        * 位于方法体的Code属性
        * 描述了**方法体**的所有**基本块(按照控制流拆分的代码块)**开始时**本地变量表**和**操作栈**应有的状态
        * 采用StackMapTable便不用根据程序推导的校验方式
        * JDK1.7主版本50以后都采用StackMapTable
4. 符号引用验证
