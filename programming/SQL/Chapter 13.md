## 13.1 事务概念
* 事务: 访问并可能更新一系列数据的一组程序执行单元(unit)
    * 特性(ACID)
        * **原子性(Atomicity)**: 整个事务要么完全执行, 要么完全不执行
        * **一致性(Consistency)**: 在没有其它事务执行时保证数据的一致性 (如转账操作)
        * **隔离性(Isolation)**: 在多个事务并发时, 在其它事务看来, 该事务要么完全没执行, 要么已经执行结束
        * **持久性(Durability)**: 提交结束的事务后, 数据不会受到故障影响
            * 方法:
                1. 事务结束之前将更新写入磁盘
                2. 保存足够信息使得在故障发生时可以恢复更新(**持久化不代表写入了磁盘**)
    * 状态:
        * 状态图
            ```
            活动状态 -> 部分提交状态 -> 提交状态
               |          |
               |          V
               |-----> 失败状态     -> 中止状态
            ```
        * 状态定义 (*逻辑定义, 与物理实现可能不同*):
            * 活动(active): 
                * 事务执行开始到最后一个语句
            * 部分提交状态(partially committed): 
                * 最后一句语句执行完
                * 尚未保存恢复信息
            * 提交状态(committed)
                * 事务执行完并保存了用于恢复的信息
                * **持久化不代表写入了磁盘**
            * 失败状态(failed):
                * 因硬件故障或者软件故障, 需要回滚, 并进行终止状态
            * 中止状态:
                * 中止后有两个选择
                    1. 重启事务: 硬件故障
                    2. 杀死事务: 软件逻辑错误, 数据无法找到, 输入错误等
            * **结束(terminated)**: **中止状态**和**中止状态**都是结束状态
    * 负责方:
        * 应用程序员: 原子性, 补偿事务 
        * 事务管理部件: 一致性
        * 并发控制部件: 隔离性
        * 恢复管理部件: 持久性, 回滚操作
## 13.4 恢复系统

### <c>13.4.1 故障类型<\c>
故障类型:
* 事务故障:
    * 逻辑错误: 非法输入, 找不到数据, 资源限制等
    * 系统错误: (数据库)系统进入不良状态(死锁等), 但事务可以推迟执行
* 系统崩溃: 故障-停止假设
    * **故障-停止假设**(fail stop assumption): 硬件或软件故障导致易失性存储器数据丢失, 非易失性存储器良好
        * // 该假设可由硬件和底层软件保障
* 磁盘故障: 由**备份**来预防

恢复算法:
1. 在正常事务处理时保存足够信息用于**故障恢复**
2. 在故障结束后, 根据信息进行恢复到某个满足**一致性**, **持久性**, **原子性**的状态

### <c>13.4.2 数据访问<\c>
定义:
* 块: 数据传送的基本单位
* 物理块
* 缓冲块
* 内存缓冲区

数据访问操作模型:
* input(B): 将物理块B从磁盘传到内存
* output(B): 将缓冲块B从内存传到磁盘

事务操作定义:
* read(X):
    ```
    if ( B_X not in RAM )
        input(B_X)
    将数据项X赋给某个变量x
    ```
* write(X):
    ```
    if ( B_X not in RAM )
        input(B_X)
    将变量x的值写入X
    ```
* 强制输出: output(X)

### <c>13.4.3 基于日志的恢复</c>
基于日志的恢复:
* 日志记录:
    * 开始: <Ti start>
    * 更新日志记录: <Ti, Xi, (V1), V2>
        * $T_i$: 事务标识符
        * $X_i$: 数据项标识符
        * $V_1$: 数据项旧值(*可选*)
        * $V_2$: 数据项新值
    * 提交: <Ti commit>
    * 中止: <Ti abort>
    ```html
    <T0 start>
        <T0, X1, 100, 200>
    <T0 committed>
    ```
* **日志必须放在稳定存储器**

#### <c>13.4.3.1 延迟修改技术</c>
延迟修改技术:
* 特点:
    * 不存旧值
    * **事务必须串行**
* 操作:
    * redo (**幂等**--多次操作结果不变)
* 机制:
    * 更新前保证所有事务的日志已写入稳定存储器
    * 故障发生时:
        1. 有commit记录的事务按时间顺序redo
        2. 无commit记录的事件忽略

#### <c>13.4.3.2 立即更新技术</c>
立即更新技术:
* 特点:
    * 保存旧值和新值
    * **事务必须串行**
* 操作:
    * redo: 幂等
    * undo: 幂等
* 机制:
    * 运行write之前先保证对应日志记录已写入稳定存储器
    * 故障发生时:
        1. 先检查无commit的事务, 进行undo操作, 将这些数据项改为原值
        2. 后检查有commit的事务, 进行redo操作, 将数据项更新

#### <c>13.4.3.3 checkpoint
* 问题:
    1. 日志太多 
    2. 重复写入
* checkpoint机制
    * 最后一个\<checkpoint\>以上的日志不用检查, 并可以删除
* 建立checkpoint的过程
    1. 保证事务对应**日志**已写入稳定存储器
    2. 保证事务中**数据项**都写入非易失存储器
    3. 在日志中加 **\<checkpoint\>**
    * // \<checkpoint\>必须放最后, 否则如果在设置\<checkpoint\>后发生故障, 则另外两个操作会被忽略
    * // 数据项的保存必须放在日志的后面, 否则如果在保存数据项后发生故障, 则日志丢失, 无法重新恢复
  