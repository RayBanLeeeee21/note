# Chapter 07 压缩列表


## 数据结构
- 压缩列表(没有对应的struct)
    ```cpp
    uint32_t zlbytes;               // 总字节数
    uint32_t zltail;                // 尾节点指针, 追加时用到
    uint16_t zllen;                 // 总元素个数
    struct ziplistEntry *entries;   // 元素
    zint8_t zlend;                  // 结束符0xFF
    ```
- `zlentry`: 该数据结构是解压后的结构, 压缩的更紧凑. 解压的方便处理
    ```cpp
    typedef struct zlentry {
        unsigned int prevrawlensize, prevrawlen; // 表示prev偏移的size, pre偏移量
        unsigned int lensize, len;               // 表示对象len的size, 对象的len
        unsigned int headersize;                 // = prevrawlensize + lensize
        unsigned char encoding;                  // 编码: 表示该
        unsigned char *p;                        // 对象数据
    } zlentry;
    ```
- 压缩列表结点(压缩)
    - previous_entry_length: 前一个结点的偏移量
        - 长度: 1/5字节
    - encoding: 表示该结点存的数据类型: 
        - 长度: 1/2/5字节
        - 字节数组: 长度为(1<<6)-1, (1<<14)-1, (1<<32)-1
        - 整型: 4位长(0-12), 1字节, 3字节, uint16_t, uint32_t, uint64_t
    - content: 内容
    - ![ziplistnode](./resources/ch07-ziplist-node.png)

特点:
- 与intset比较: intset每个元素的长度固定, 而ziplist元素不定长
- previous_entry_length不定长可能带来的问题:
    - **连锁更新**: 如果插入/删除结点后续的结点都处于靠近边界值的状态, 则可能会造成连锁更新. 严重影响性能
        - 插入: 假设插入结点的后续结点的长度都快突破254字节, 而插入的结点超过了254字节, 则会造成后续结点的`previous_entry_length`都从1字节变成5字节
        - 删除: 假设删除结点的后续结点的长度都快低于254字节, 而删除后, 被删结点的`previous_entry_length`从5字节变成1字节, 则后续结点的`previous_entry_length`也跟着变成1字节

## 使用场景
- 列表键实现之一(小尺寸整数或字符串)
- 哈希键实现之一(小尺寸整数或字符串)


## quicklist
// todo