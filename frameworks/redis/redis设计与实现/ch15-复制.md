# Chapter 15 复制



复制功能
- 同步(SYNC): 让从服务器达到与主服务器一致的状态
- 命令传播: 主服务器接收到客户端命令修改数据时, 将命令传播到从服务器去执行, 使状态重新一致

SYNC实现
1. 从服务器向主服务器发送SYNC请求
2. 主服务器收到请求, 同时
    1. BGSAVE生成RDB文件
    2. 开启一个缓冲, 用来记录BGSAVE过程中收到的命令
3. 主服务器将RDB发给从服务器载入
4. 主服务器将缓冲区的数据发给从服务器执行


旧版复制功能的缺陷: 断线重连SYNC的时候, 会把旧的数据也重新"导出-载入"

SYNC命令很耗费资源
1. 主服务器执行BGSAVE时硬盘和CPU开销大
2. 主服务器发RDB文件的时候网络开销大
3. 载入RDB时, 从服务器开销大, 并且**不可用**(阻塞)


`PSYNC runid offset`
- 参数: 
    - runid: 主服务器实例运行ID
    - offset: 命令偏移
- 两种模式:
    - 完整重同步: 适用于初次同步
    - 部分重同步: 适用于断线后重连

## 15.4 部分重同步实现 

复制偏移量:
- 主从机器都会记录复制偏移量
    - 主服务器的偏移量减从服务的偏移量即是未复制的部分
    - 偏移量一致表示处于同步状态

**复制积压缓冲区**: 主服务器会把近期发过的命令存在该缓冲区
- 作用:
    - 从服务器的`PSYNC`命令的offset大于复制积压缓冲区时, 主服务器从复制积压缓冲区取命令发回给从服务器(部分重同步)
    - 从服务器的`PSYNC`命令的offset小于复制积压缓冲区时, 主服务器告诉从服务器进行完整重同步
- 缓冲大小调整: 应该大于 `平均断线时长(s) * 写命令生成数/s`

`PSYNC`实现 
1. 从服务器向主服务器发`PSYNC masterId offset`, 其中`offset=-1`表示完整重同步
2. 主服务器返回
    1. offset >= 复制积压缓冲区起点 
        - -> `+CONTINUE` -> 从服务器等待主服务器返回数据
    2. offset <  复制积压缓冲区起点 
        - -> `+FULLSYNC masterId offset` -> 从服务器等待主服务器将重同步后的RDB发过来


## 15.6 复制的实现

复制: `SLAVEOF masterId masterPort`
1. 从服务器中记录主服务器ID与port
    ```cpp
    struct redisServer {
        char * masterhost;
        int masterport;     
    }
2. socket连接
    - 连接成功后, 主服务器会将从服务器当作一个客户端, 为其创建客户端及文件事件处理器
3. 检查: 服务端发PING
    - 可能结果
        1. 超时 -> 重试
        2. 错误 -> 重试
        3. PONG -> 下一阶段
4. 身份验证
5. 从服务器发送自己的服务端端口, 存到主服务器中的`client`对象中
    -   ```cpp
        typedef struct client {
            int slave_listening_port; 
        }
        ```
    - 后续主服务器要作为从服务器的客户端
6. 开始同步(`PSYNC`): 主服务器也成为了从服务器的客户端, 从服务器可以接收其命令
7. 命令传播: 重同步后, 进入命令传播阶段, 主服务器在收到写命令时, 也复制给从服务器


## 15.7 心跳检测

心跳: `REPLCONF ACK replOffSet`
- 作用: 
    - 检测连接
    - 通知主服务器同步进度
    - 检测命令丢失: 类似TCP丢失报文后补发的机制
    - min-slave实现手段

min-slave: 在网络条件不好以致**无法完成复制**时, 拒绝完成写命令
- 实质上是为保证**一致性**而牺牲**可用性**
- 条件:
    - `min-slave-to-write`: 最小slave存活数量
    - `min-slave-max-lag`: 最大slave延迟
        - 所有从服务器都超过才生效



