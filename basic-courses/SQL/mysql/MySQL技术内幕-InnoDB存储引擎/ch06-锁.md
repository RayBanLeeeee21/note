# Chapter 06 锁

MyISAM只支持表锁
Microsoft SQL Server开销很大

innodb锁特性: 
- 行级锁
- 一致性非锁定读(MVCC实现)

## 6.2 lock与latch

innodb中的锁:
|                    |latch                       | lock             |
|:-------------------|:---------------------------|:-----------------|
|持有锁的单元         | 事务                       | 线程              |
|持续时间(锁的范围)   | 整个事务生命周期             | 临界区           |
|形式                | {行锁, 表锁, 意向锁}x{读写锁}| 读写锁, 互斥量    |
|死锁解决            | wait for graph, time out    | 由程序实现保证    |
|保存在              | Lock Manager的哈希表        | 分散在各数据结构中 |

可以通过`show engine innodb mutex`查询

## 6.3 InnoDB引擎中的锁

### 6.3.1 锁的类型

InnoDB的锁
- 多粒度锁
    - 表级
    - 页级
    - 行级
- 互斥类型
    - 共享锁(S, Share)
    - 排他锁(X, eXclusive)
    - 意向锁(IX/IS, Intention)

多粒度意向锁加锁规则:
- 如果要对下级加锁, 则要**自上而下**给所有上级加对应的意向锁
- 互斥规则:
    - X与X互斥, X与S互斥 (X与所有都互斥)
    - IX与IX, IX与IS均不互斥
    - IX与S互斥, IS与X互斥, IS与S不互斥

### 6.3.2 一致性非锁定读

一致性非锁定读:
- 原理: MVCC(多版本并发控制)
    - 实现: 事务会产生undo日志, 可以直接从undo页中拿到之前提交过的版本
- 隔离级别
    - READ UNCOMMITTED: 事务A可以直接读到事务B未提交的数据
    - READ COMMITTED: 事务A总是读到数据最新提交的版本
    - REPEATABLE READ: 事务A总是读到事务A开始之前可以见到的最后一个提交的版本

### 6.3.3 一致性锁定读

共享锁使用方法:
- 排他锁: 
    - `SELECT ... FOR UPDATE`
    - 在事务中使用update
- 共享锁: 
    - `SELECT ... LOCK IN SHARE MODE`

### 6.3.4 自增长与锁

参考官方文档[14.6.1.6 AUTO_INCREMENT Handling in InnoDB](https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html)

自增锁(AUTO-INC): 事务进行插入时, 会对主键产生竞争, 可以通过自增锁来同步
- 表级自增锁: **特殊表锁**,  在事务中的插入语句结束后释放(不用等事务结束)
- 非表级自增锁: 每次插入操作都抢一次锁

插入类型:
- insert-like
    - simple insert: 在一开始就能确定增长的条数
        - `insert/replace ... where k = v`
    - bulk insert: 一开始不能确定增长的条数
        - `insert/replace ... select ...`: 不确定select会有多少条
    - mixed-mode insert: 一部分确实, 一部分不确定, **但能确定上限**
        - `insert ... values (NULL, ...), (1, ...)`: 有些主键给了定值, 有些给了NULL
        - `insert ... on duplicate key update`: 1/0条

自增加计数器锁模式(`innodb_autoinc_lock_mode`):
- 0-traditional: 所有情况都使用表级自增锁
    - 保证statement-based binlog重放顺序不变
        - 重放时, binlog上事务顺序与执行时顺序一致
        - 事务内插入操作也是顺序的
- 1-consecutive: simple insert使用非表级自增锁, bulk insert使用表级自增锁
    - 保证statement-based binlog重放顺序不变
        - 重放时, binlog上事务顺序与执行时顺序一致
        - 事务内插入操作也是顺序的(simple insert一开始能确定要分配几个主键值, 而bulk insert因为使用了表级自增锁, 所以也是顺序的)
    - 对于`update...insert``如果源表与插入表不同, 则会先给源表加S锁; 如果相同, 则给选中的行加S锁
    - 语义基本与0-traditional相同, 除了对**mixed-mode insert**的表现不同
        - mixed-mode insert可以确定上限, 因此可以超额分配, 然后超出的丢弃
- 2: 所有insert-like都使用非表级自增锁
    - **不保证statement-based binlog重放顺序**


自增列注意事项:
- 自增锁模式为2时, binlog要设置为row based才能保证顺序一
- *自增锁的值不会随着事务回滚而回滚*, 回滚之前生产的值都会丢失
- 0和NULL会被当成接着上一次的值增长
- **赋予负值的结果是未定义的**


**自增值的列必须是索引中的第一列**

**MyISAM只有表锁, 因此不用担心自增值的问题**

### 6.3.5 外键和锁

外键
- 实现方法: 索引+S锁
    - 因此innodb自动给外键列, 建索引, 而且不能有索引
- 插入外键之前先给依赖的记录加共享锁

## 6.4 锁的算法

innodb中的行锁算法
- 行记录锁: 通过索引锁单个行记录
    - e.g.: `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`会阻止其它事务增删改c1=10的记录
    - 加锁对象: 行记录
- 间隔(gap)锁: 锁定两个行记录中间的间隔, 或第一个行记录之前/最后一个行记录之后的范围
    - e.g.: `SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE`会阻止c1=15的记录插入
    - 加锁对象: 
    - 