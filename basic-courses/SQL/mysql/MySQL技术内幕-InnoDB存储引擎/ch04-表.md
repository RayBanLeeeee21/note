# Chapter 04 表

## 4.1 索引组织表

索引组织表: 表都是按主键顺序存放

innode主键:
- 创建规则: 
  - 找**首个定义**的**非NULL**&**唯一**索引
    - *匹配到时, _rowid可以作为该字段的别名(多字段索引除外)*
  - 找不到再隐式创建一个6字节的_rowid字段

## 4.2 InnoDB逻辑存储结构


层次:
- 表空间: 单个文件, 包含不同的段
- 段: 每个段由相同类型的页组成
  - 数组段, 回滚段, undo段
- 区: 磁盘空间分配的基本单位
- 页: 缓冲的基本单位

### 4.2.1 表空间

表空间:
- 独立表空间(`innodb_file_per_table=ON`): 可以设置每个表一个表空间
  - 独立表空间
    - 只存放: 数据, 索引, 插入缓冲bitmap. *其它页放在共享表空间*
  - 共享表空间: ibdata1
    - 存放: 系统页, undo页, 事务数据页, 插入缓冲索引等. *以及独立表空间支持的页类型*

### 4.2.3 区

区:
- 单位:
  - 区: 一个区1MB, 默认64个页
  - 页: 一个页默认16KB, 不过可以设置
    - 如果表有独立表空间, 则初始分配6个页, 然后在达到32页前分配碎片页(即按页分配), 超过后开始按区分配


### 4.2.4 页

页:
- **数据页**
- **undo页**
- 系统页
- 事务数据页
- **插入缓冲bitmap页**
- **插入缓存空闲页**
- 未压缩的二进制大对象
- 压缩的二进制大对象


## 4.3 InnDB行记录格式 

行记录格式
- Compact
- Redundant


### 4.3.1 Compact行记录格式 

Compact行记录格式
- 变长字段长度列表 (1/2 byte): **逆序**
- NULL标记位 (8 bit): 
- record header(40 bit)
- 列数据

记录头(record header) 
```
deleted_flag    是否被删除
min_rec_flag    是否最小的记录
n_owned         该记录头下面放了几条连着的记录
heap_no         第一条记录的序号(相对整个表)
record_type     记录类型(000: 普通 001: B+树节点指针 010: Infimum 011: Supremum)
next_record     下一条记录的相对位置
```
- Infimum 第一条记录前用来占位的伪记录
- Supremum 最后一条记录后用来占位的伪记录


列数据:
- 隐藏列: 实际数据列前面还有几个隐藏列
  - rowid: 如果没有非空唯一索引, 则自动创建该列
  - trxId: 事务ID
  - rollPointer: 回滚指针
- CHAR填充: 填充空格(0x20)


Q: 怎么知道变长字段长度列表有多少个字段?
// TODO

### 4.3.2 Redundant行记录格式

Redundant行记录格式
- 字段长度偏移列表: **逆序**
- record header(48 bit)
- 列数据


两种格式的主要区别:
- Compact存储CHAR/VARCHAR的NULL不占空间(除了固定的NULL标志位), 而Redundant存储CHAR的NULL占空间


### 4.3.3 行溢出数组

行溢出:
- 对于VARCHAR/BLOB/TEXT类型, 如果一页不能放下两条记录, 则会发生行溢出, 在数组页中只存列数据中768字节的前缀, 剩余部分放到BLOB页, 通过768字节后的指针指向BLOB页

### 4.3.5 CHAR的行结构存储

CHAR(N)中的N指的是字符个数(不是字节), 因此多字节字符的情况下, CHAR与VARCHAR都要保存长度


## 4.4 InnoDB数据页结构 

**(直接看书上的例子)**

InnoDB数据页
- File Header (文件头)
- Page Header (页头)
- Infimum + Supremum
- User Record (用户记录)
- 空闲空间
- File Trailer

## 4.6 约束

域完整性保证
- 数组类型限制
- 外键约束
- 触发器
- Default作为补充

// TODO

## 4.8 分区

// TODO