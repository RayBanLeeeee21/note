# chapter 05 远程调用

远程过程调用(Remote Procedure Call): 
* 将过程调用的概念扩展到分布式系统

远程方法调用(Remote Method Invocation): 
* 将面向对象的概念(包括对象引用等)扩展到分布式系统


## 5.2 **请求-应答协议**

适用: **C/S场景**

特点:
* **可靠**: **确认机制**保证
* 同步或异步

#### 5.2.x.x 用**UDP**实现请求-应答协议

适用: 参数和结果的 **数据比较少**

优点: 与TCP相比, 节省开销:
* **确认**开销: 将确认放在应答中
* **流控制**开销: 在参数和结果比较少的情况下, 流控制不必要
* **连接**开销: 除了一对请求-应答以外, 建立连接还需要两对消息(建立与断开连接时交换的数据)


请求原语:
* doOperation
* getRequest
* sendReply

操作原语
* 参数:
    ```java
    
    // 请求方的接口
    //  1. 同步方法, 阻塞直到得到结果
    //  2. 调用者要负责对参数的编码, 和对结果的解码
    byte []                     // 返回: 包含应答内容的字节数 
    doOperation(
        RemoteRef ref,          // 远程引用: 包含了主机地址(IP 端口), 可能有对象标识等信息
        int operationId,        // 操作类型: 如增删改查等
        byte [] arguments,      // 参数: 编码为字节数组
    );
    
    // 接收方接口
    byte [] getRequest();       // 获取一个请求

    // 请求中的信息
    Class Message{
        // doOperation负责生成的字段, 可看作RR协议字段
        int messageType;        // 0=请求, 1=响应
        int requestId;          // 对请求方来说唯一的请求标识    

        // doOperation的参数
        RemoteRef ref;          // 远程调用请求
        int operationId;        // 操作类型
        byte [] arguments,      // 参数: 编码为字节数组
    }

    //接收方接口
    void sendReply( 
        byte[]reply,            // 应答结果
        InetAddress clientHost, // 请求方主机
        int clientPort          // 请求方端口
    );
    
    ```
* 请求标识符:
    * requestId: 对请求端是唯一的 (时间上唯一)
    * requestId + 请求方IP:端口: 对整个分布式系统是唯一的 (时空中唯一)
  
故障模型:
* 故障类型:
    * 通道遗漏故障: 请求丢失, 应答丢失
    * 进程遗漏故障: 故障停止
    * 失序
    * 随机故障-重复
* 应对机制:
    * 通道遗漏故障: 请求方 **超时机制** 检测, **重传** 实现故障屏蔽
    * 进程故障: 超时机制检测+计数重传, 确认是进程故障后将结果上报
    * 失序: 通过序号检测
    * 随机故障-重复:
        * 请求重复: 
            * 支持幂等操作: 重新操作, 重新返回结果
            * 不支持幂等操作: 应答方记录 **历史**, 重新返回结果
        * 应答重复:
            * 直接丢弃
    
历史机制的开销: 请求多时, 历史占用较多内存
* 优化: 把下个请求作为请求方对于上一个应答的确认, 确认后清除上个结果
    * 新问题: 如果有大量客户, 每个客户发少量请求时, 仍然会很占内存

#### 5.2.x.x 交互协议类型

交互协议类型:
* R协议 (Request Protocol)
    * 无结果且无须确认时可使用
* RR协议 (Request-Reply Protocol)
* RRA协议 (Request-Reply-Acknowledge Protocol)
    * 与RR协议相比, 多一个客户确认
    * 因为一个确认序号(n)隐含着对于前续所有序号(n-1, n-2)的确认, 所以 **确认丢失损失较小**
  
![](resources/rpc_exchange_protocol.jpg)


基于TCP流的请求-应答协议实现:
* 面向字节流, 可以传递任意长的信息，避免实现多包协议
* 实现协议时没有必要考虑重传, 重复, 发送等, TCP协议已保证可靠性
* 建立一次连接可以传输多次请求和应答


HTTP与请求-应答协议中消息的对应关系
* messageType -- 请求头与响应头
* requestId -- 无对应参数, 但可以自定义HTTP首部或HTTP实体
* remoteRef -- URL (主机+端口+相对URL)
* operationId -- 请求头的HTTP方法
* arguments -- HTTP首部 / HTTP实体


## 5.3 RPC

RPC相关问题:
* **接口编程**
* 调用语义
* 透明性

### 5.3.1 RPC的设计问题

#### 5.3.1.x 接口编程

接口编程: 
* 模块通信方法:
    * 过程调用
    * 变量访问
* **接口**: 定义模块能被调用的过程及其参数


服务接口: 
* 特征: 模块可**跨进程调用**, **跨平台(语言)调用**
    * 另一个模块的**地址空间**不能使用
        * 模块成员变量不能访问 (但可以动态生成getter和setter)
        * 参数传递机制(值传递, 引用传递)不能使用
* 优点:
    * 抽象
    * 不用了解平台底层
    
接口定义语言(IDL): 允许**不同语言**实现的过程相互调用
* 参数类型:
    * 输入型参数
    * 输出型参数


#### 5.3.1.x RPC调用语义

容错措施 / 传输保证:
* 重发请求
* 过滤重复请求
* 重新执行/重传结果

调用语义:
* 或许执行语义: 仅适合能接收偶然错误的应用
    * 遗漏故障: 请求或结果丢失
    * 系统崩溃: 服务器崩溃
* 至少执行一次语义: 服务器的操作必须是幂等 
    * 随机故障: 重复执行导致错误
    * 系统崩溃
* 至多执行一次语义

|**语义**|**重发请求**|**过滤重复请求**-**重新执行**-**重传结果**|故障|场景|
|:-:|:-:|:-:|:-:|:-:|
|或许执行|N|-|遗漏, 崩溃|可接受偶然错误|
|至少一次|Y|N-Y-N|随机, 崩溃|服务器操作幂等|
|至多一次|Y|Y-N-Y|崩溃||


#### 5.3.2 RPC的实现

RPC中的角色:
* 客户进程
* 服务器进程

客户进程:
1. 客户程序
2. 客户存根过程: *可根据接口定义动态生成*
    1. 把参数与过程标识**编码**成请求
    2. 通过**通信模块**发送请求并接收
    3. **解码**结果
3. 通信模块: 根据特定协议, 发送请求, 接收应答

服务器进程:
1. 分发器: 通过**通信模块**接收请求并解析, 分发给特定存根过程
2. 服务器存根过程: *可根据接口定义动态生成*
    1. **解码**过程标识符和参数
    2. 根据过程标识符选择过程, 输入参数调用过程
    3. **编码**结果, 并通过通信模块返回应答
3. 服务过程
4. 通信模块: 根据特定协议, 接收请求, 发送应答

![](resources/role_of_rpc.png)


### 5.3.3 实例研究: Sun RPC
Sun RPC中的表示方法: 
* 程序唯一标识符: **程序号 + 版本号**
* 过程唯一标识符: **程序号 + 版本号 + 过程号**
    * 程序号: 由授权中心分发
    * 过程号: 标识过程在程序中的编号
    * 版本号: 随 **过程签名** 发生改变而增加
        * **过程签名**: 返回类型 + 过程名 + 参数类型, 如``int fun(int a, int b);``
* 过程定义: 过程号 + 方法签名
* 单个参数, 单个返回值
* e.g.:
    ```c
    // 结果只能有一个, 定义在一个结构体中
    struct Data{
        int length;
        char buffer[MAX];
    };

    // 参数只能有一个, 定义在一个结构体中
    struct writeargs{
        FileIdentifier f;
        FilePointer p;
        Data data;
    };
    struct readargs{
        FileIdentifier f;
        FilePointer p;
        Length length;
    };

    program FILEREADWRITE{
        version VERSION{
            // 过程定义 = 过程签名 + 过程号 = (返回类型 + 过程名 + 参数类型) + 过程号
            void WRITE(writeargs)=1;    // 过程号
            Data READ(readargs)=2;      // 过程号
        } = 2;                          // 程序版本号
    } = 9999;                           // 程序号
    ```

Sun RPC的其它功能:
* 端口映射器: 记录 **(程序号+版本号)-->端口** 的映射关系, 来将请求交给对应端口
    * 端口映射器可用于实现本机中的组播
        * 用户将RPC请求通过UDP组播到各主机, 主机内通过端口映射器组播到各端口
* 认证方式:
    * 没有认证
    * UNIX风格认证: uid+gid
    * 共享密钥的风格 ?
    * kerberos ?


## 5.4 RMI

RMI与RPC比较:
|功能/特点|RMI|RPC|
|:-|:-:|:-:|
|接口编程|Y|Y|
|调用语义|或许, 至少, 至多|或许, 至少, 至多|
|透明性|Y(但可支持远程异常)|Y|
|面向对象|N|Y|
|对象引用|N|Y(在分布式系统中唯一)|

RMI相关问题:
* 对象模型

### 5.4.1 RMI的设计问题
#### 5.4.1.x 对象模型 *

**对象模型**相关概念:
* 对象引用: 要调用对象方法必须拥有对象引用
* 接口: 定义方法的参数类型, 返回值, 异常类型
* 调用动作: 可产生不同结果
    * 对象状态改变
    * 产生新对象: 引发新对象的实例化
    * 间接调用: 触发一系统间接的方法调用
* 异常: 可以捕获异常并处理, 或者抛出
* 无用单元收集/垃圾收集

#### 5.4.1.x 分布式对象与体系

分布式对象与体系结构
* C/S体系结构: 对象放在服务器中, 客户端通过RMI来调用对象的方法
    * 面向对象的程序是从逻辑上划分的, 可以方便地分到不同服务器中
    * 将客户端对象与服务器对象通过进程来分隔可提高**封装性**
* 复制服务: 提高性能, 增强容错能力
* 迁移对象: 提高性能, 提高可用性

#### 5.4.1.x 分布式对象模型
**分布式对象模型** 对于对象模型的扩展
* 方法调用:
    * 远程方法调用: 不同 **进程** 的对象方法调用 (不管进程是否在同一服务器)
    * 本地方法调用: 同一 **进程** 的对象方法调用
* 对象引用: 
    * 可跨进程
    * **远程对象引用** 在整个分布式系统中唯一 (时间和空间)
* 接口: **远程接口** 可通过 **跨语言** 的IDL来定义
* 调用动作: 
    * 产生新对象:
        * 构造函数不能远程调用, 但是可以通过普通方法实现 (如工厂), 
        * 对象生命周期: 取决于实例化该对象的进程
    * 间接调用: 触发一系列的RMI动作
* 异常:
    * 除对象声明的异常以外, 还要处理**分布式带来的异常**, 如超时异常
* 无用单元收集/垃圾收集:
    * 分布式垃圾回收模块

### 5.4.2 RMI实现

RMI中的角色:
* 客户端进程
* 服务端进程

RMI软件模块
* 通信模块: 传递消息
    * 可选参数: 协议(如RR, RRA), 调用语义
    * 必要的传递参数: messageType, requestId, remoteRef
* 对象引用模块
    * 为本地拥有的远程对象创建 **远程对象引用**  (代理对象的远程对象引用由被代理对象所在主机的对象引用模块创建) 
    * 负责**远程对象引用-本地对象引用**之间的翻译
    * 远程对象表:
        * 记录本地中管理的远程对象
        * 记录本地中的 **代理对象**
    * 机制:
        * 将本地中的对象第一次传递(作为参数或结果)给其它机器时, 为其创建 **远程对象引用**
        * 将收到的(请求或应答)的 **远程对象引用** 翻译成 **本地对象引用**
            1. 如果远程对象引用有对应的本地对象引用, 则提供该本地对象引用
            2. 如果远程对象引用无对应的本地对象引用, 为该远程对象引用创建代理对象, 并记录该代理对象的本地对象引用


<!-- 
RMI软件中的角色:
* 客户端: 
    * 代理: 对用户隐藏远程对象
        * 接口与被代理的远程对象完全一致, 负责生成RMI消息, 发给服务端, 然后将结果解码返回给用户
        * *动态调用* ?
* 服务端:
    * servant: 实现远程接口的远程对象实例主体
    * 骨架(skeleton): 每个 **远程对象类** 有一个对应的骨架  
        1. 负责请求消息的解码
        2. 根据对象引用和methodId调用servant中的方法
        3. 将结果或异常编码到应答消息, 返回给代理类
        * *动态骨架* ?
    
RMI软件的程序:
* 服务端
    * 初始化: 
        * 初始时至少创建一个servant, 其余servant应客户端的调用而生
            * 客户请求创建对象时, 不能远程调用构造函数, 但可以通过 **工厂方法**
        * 初始时也可以用绑定程序对初始的servant进行注册
    * 服务器线程: 对每个RMI的执行都分配一个线程
* 客户端:
    * 绑定程序: 管理 **对象名--远程对象引用** 的映射关系 
-->
