# Chapter 03 垃圾收集器与内存分配策略

内存区域能否提前确定内存大小
- 能确定的: 程序计数器, Java虚拟机栈, Native方法栈
    - *Java虚拟机栈只是大致确定*, 因为涉及到栈上分配, 标量替换等优化
- 不能确定: 堆, 方法区

## 3.2 对象已死?
引用计数法: 给对象的引用计数
- *使用场景*: redis
- 问题: 循环引用

### 3.2.2 可达性分析算法

从GC Root出发:
- 虚拟机栈的参数, 局部变量, 临时变量
- Native栈中的引用
- 方法区中类的静态属性
- 常量池中的常量
- Java虚拟机中常驻的Class对象(NullPointException, OutOfMemoryError等)
- 被synchronized的对象
- 反映虚拟机内部的JMXBean, JVMTI中的回调, 本地代码缓存等

### 3.2.3 再谈引用

引用类型:
- 强引用: 所有"="赋值的都是强引用
- 软引用: 在内存快溢出时, 会把软引用回收掉
- 弱引用: 只要GC扫描到, 就会回收
- 虚引用: 无法通过虚引用拿到对象引用, 但是被回收时会加到一个队列, 回收以后能从队列中找到, 从而知道被回收了
    - *应用场景*: 清理`DirectBuffer`用的`Cleaner`


### 3.2.4 生存还是死亡?

`Finalizer`类
- 有两个阻塞队列:
    1. 保存`finalize()`方法被覆写过的对象
    2. (阻塞队列)保存被GC标记过的对象
- 对象的`finalize()`执行过程
    1. 第一次被GC后, 对象被标记, 从队列1加到队列2
    2. 有个低优先级的Finalizer线程会不断从阻塞队列拿对象执行其`finalize()`方法, 并移除掉
    3. 第二次被GC后, 对象就真的被回收了


### 3.2.5 回收方法区

被回收对象
- 常量
- 类: 可回收条件
    - 所有实例被回收
    - 其ClassLoader也被回收
    - 没有对其Class对象的引用, 也无法通过反射获得对其的引用

相关命令: 
- `-verbos:class`
- `-XX:+TraceClassLoading`
- `-XX:+TraceClassUnLoading`

## 3.3 垃圾回收算法

分代假说
1. 弱分代假说: 对象大多数是朝生夕灭
2. 强分代假说: 撑过越多代的对象越难消亡
3. 跨代引用假说: 跨代引用相对同代引用占极少数
    - 记忆集 

GC范围
- Full GC
- Partial GC
    - Minor / Young GC
    - Major / Old GC
    - Mixed GC

算法
- 标记-清除(Mark-Sweep): 
    - 问题: 要把可回收的区域都找出来, 开销大; 内存碎片
- 标记-复制(Copying)
    - 问题: 
        - 空间利用率低 -> 优化: Eden-Survivor
        - Survivor不能保证存下所有剩余对象 -> 优化: 由老年代做担保
- 标记-整理(Mark-Compact)
    - 问题:
        - Stop-the-World: 该算法会与用户线程竞争空闲区域, 因此要暂停用户线程

## 3.4 HotSpot的算法细节实现

参考
- [浅析OopMap](https://blog.csdn.net/asdasd3418/article/details/77686653)
    > 在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的。 
      
    > 可以把oopMap简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。  

    > 每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置主要在： 
    > 1、循环的末尾 
    > 2、方法临返回前 / 调用方法的call指令后 
    > 3、可能抛异常的位置
    > 这种位置被称为“安全点”（safepoint）

### 3.4.1 根节点枚举 - OopMap & 安全点

OopMap
- 解决的问题: Stop-the-World, 枚举开销大
- OopMap: 记录栈中哪个位置是什么类型数据, 加快枚举过程
    - 问题: 更新OopMap本身要开销, 不能一发生修改就更新

### 3.4.2 安全点
 
SafePoint: 放OopMap的地方; 可以进行GC的点
- 作用:
    - 统一在SafePoint处更新OopMap
    - 在SafePoint处执行GC
- 选取原则: 在可能发生长时间执行的地方, 如*循环结尾*, *方法返回前, call指令后*, *可能抛异常的地方*等. 
    - 为什么?:
        1. 放在这些地方, 线程可以比较频繁地"踩"到这些点上, 而不会在需要进行GC时, 要运行很久才到点上
        2. 安全点的数量又会比较少(跟方法块/循环块的数量成正比), 同时OopMap的尺寸也很小(跟方法块/循环块中的局部变量数成正比)
        3. 单个方法不会因为指令太多而长时间执行(再长也长不到哪去).

### 3.4.3 安全区域

SafePoint中断方法
- 抢占式中断: 由jvm暂停所有线程, 并让没跑到安全点的线程跑到安全点
- 主动式中断: jvm在要gc时, 设置一个标志. 线程在到达安全点时检查该标志位, 有就挂起
    - HotSpot实现: trap异常信号触发中断

SafeRegion
- SafePoint的缺点: 线程可能SLEEP/BLOCKED了
- SafeRegion原理
    - jvm在需要进行GC时设置标志, 并且不管SLEEP/BLOCKED状态的线程(已经进入了安全区)
    - SLEEP/BLOCKED状态的线程被唤醒后, 会检查标志, 并且直到GC完成才离开安全区

### 3.4.4 记忆集与卡表

记忆集: 记录非收集区域指向收集区域的指针集合
- 精度:
    - 字长精度: 某个字(32/64 bit)有指向收集区域的指针
    - 对象精度: 某个对象有指向收集区域的指针
    - 卡精度: 某个内存区域有指向收集区域的指针

卡表(卡精度): 用位数组来标识某个内存区域(card)是否有指向收集区域的指针

### 3.4.5 写屏障

写屏障: 可看作通过指令实现的针对写操作的切面
- 问题: 缓存行的伪共享. 解决方法: 只有变脏(0->1)时才去更新卡表的标志
- 作用:
    - 在写屏障中做更新卡表的操作

### 3.4.6 并发的可达性分析


并发条件下进行可达性分析的方法
- 三色标记法
    - 黑色: 扫描完成的对象
    - 灰度: 已被访问, 但对象中有引用没扫描完的对象
    - 白色: 未被扫描的对象
- 三色模型中的"消失问题"条件
    1. 在黑色对象中新增引用
    2. 在灰色对象中删除引用
- 三色标记法与并发
    - 增量更新: 用户线程在黑色对象中新增引用时, 要记录下来, 在并发扫描结束后再次扫描
    - 原始快照: 用户线程在灰色对象中删除引用时, 要记录原来的指针, 在并发扫描结束后再次扫描
