# Chapter 03 垃圾收集器与内存分配策略

内存区域能否提前确定内存大小
- 能确定的: 程序计数器, Java虚拟机栈, Native方法栈
    - *Java虚拟机栈只是大致确定*, 因为涉及到栈上分配, 标量替换等优化
- 不能确定: 堆, 方法区

## 3.2 对象已死?
引用计数法: 给对象的引用计数
- *使用场景*: redis
- 问题: 循环引用

### 3.2.2 可达性分析算法

从GC Root出发:
- 虚拟机栈的参数, 局部变量, 临时变量
- Native栈中的引用
- 方法区中类的静态属性
- 常量池中的常量
- Java虚拟机中常驻的Class对象(NullPointException, OutOfMemoryError等)
- 被synchronized的对象
- 反映虚拟机内部的JMXBean, JVMTI中的回调, 本地代码缓存等

### 3.2.3 再谈引用

引用类型:
- 强引用: 所有"="赋值的都是强引用
- 软引用: 在内存快溢出时, 会把软引用回收掉
- 弱引用: 只要GC扫描到, 就会回收
- 虚引用: 无法通过虚引用拿到对象引用, 但是被回收时会加到一个队列, 回收以后能从队列中找到, 从而知道被回收了
    - *应用场景*: 清理`DirectBuffer`用的`Cleaner`


### 3.2.4 生存还是死亡?

`Finalizer`类
- 有两个阻塞队列:
    1. 保存`finalize()`方法被覆写过的对象
    2. (阻塞队列)保存被GC标记过的对象
- 对象的`finalize()`执行过程
    1. 第一次被GC后, 对象被标记, 从队列1加到队列2
    2. 有个低优先级的Finalizer线程会不断从阻塞队列拿对象执行其`finalize()`方法, 并移除掉
    3. 第二次被GC后, 对象就真的被回收了


### 3.2.5 回收方法区

被回收对象
- 常量
- 类: 可回收条件
    - 所有实例被回收
    - 其ClassLoader也被回收
    - 没有对其Class对象的引用, 也无法通过反射获得对其的引用

相关命令: 
- `-verbos:class`
- `-XX:+TraceClassLoading`
- `-XX:+TraceClassUnLoading`

## 3.3 垃圾回收算法

分代假说
1. 弱分代假说: 对象大多数是朝生夕灭
2. 强分代假说: 撑过越多代的对象越难消亡
3. 跨代引用假说: 跨代引用相对同代引用占极少数

GC范围
- Full GC
- Partial GC
    - Minor / Young GC
    - Major / Old GC
    - Mixed GC

算法
- 标记-清除(Mark-Sweep): 
    - 问题: 清理动作开销大; 内存碎片
- 标记-复制(Copying)
    - 问题: 
        - 空间利用率低 -> 优化: Eden-Survivor
        - Survivor不能保证存下所有剩余对象 -> 优化: 由老年代做担保
- 标记-整理(Mark-Compact)
    - 问题:
        - Stop-the-World: 该算法会与用户线程竞争空闲区域, 因此要暂停用户线程

## 3.4 HotSpot的算法细节实现 - OopMap & 安全点

OopMap + SafePoint
- 解决的问题: Stop-the-World, 枚举开销大
- OopMap: 记录栈中哪个位置是什么类型数据, 加快枚举过程
- 

