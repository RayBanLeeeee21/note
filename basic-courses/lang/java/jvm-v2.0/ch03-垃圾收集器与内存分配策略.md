# Chapter 03 垃圾收集器与内存分配策略

内存区域能否提前确定内存大小
- 能确定的: 程序计数器, Java虚拟机栈, Native方法栈
    - *Java虚拟机栈只是大致确定*, 因为涉及到栈上分配, 标量替换等优化
- 不能确定: 堆, 方法区

## 3.2 对象已死?
引用计数法: 给对象的引用计数
- *使用场景*: redis
- 问题: 循环引用

### 3.2.2 可达性分析算法

从GC Root出发:
- 虚拟机栈的参数, 局部变量, 临时变量
- Native栈中的引用
- 方法区中类的静态属性
- 常量池中的常量
- Java虚拟机中常驻的Class对象(NullPointException, OutOfMemoryError等)
- 被synchronized的对象
- 反映虚拟机内部的JMXBean, JVMTI中的回调, 本地代码缓存等

### 3.2.3 再谈引用

引用类型:
- 强引用: 所有"="赋值的都是强引用
- 软引用: 在内存快溢出时, 会把软引用回收掉
- 弱引用: 只要GC扫描到, 就会回收
- 虚引用: 无法通过虚引用拿到对象引用, 但是被回收时会加到一个队列, 回收以后能从队列中找到, 从而知道被回收了
    - *应用场景*: 清理`DirectBuffer`用的`Cleaner`


### 3.2.4 生存还是死亡?

`Finalizer`类
- 有两个阻塞队列:
    1. 保存`finalize()`方法被覆写过的对象
    2. (阻塞队列)保存被GC标记过的对象
- 对象的`finalize()`执行过程
    1. 第一次被GC后, 对象被标记, 从队列1加到队列2
    2. 有个低优先级的Finalizer线程会不断从阻塞队列拿对象执行其`finalize()`方法, 并移除掉
    3. 第二次被GC后, 对象就真的被回收了


### 3.2.5 回收方法区

被回收对象
- 常量
- 类: 可回收条件
    - 所有实例被回收
    - 其ClassLoader也被回收
    - 没有对其Class对象的引用, 也无法通过反射获得对其的引用

相关命令: 
- `-verbos:class`
- `-XX:+TraceClassLoading`
- `-XX:+TraceClassUnLoading`

## 3.3 垃圾回收算法

分代假说
1. 弱分代假说: 对象大多数是朝生夕灭
2. 强分代假说: 撑过越多代的对象越难消亡
3. 跨代引用假说: 跨代引用相对同代引用占极少数
    - 记忆集 

GC范围
- Full GC
- Partial GC
    - Minor / Young GC
    - Major / Old GC
    - Mixed GC

算法
- 标记-清除(Mark-Sweep): 
    - 问题: 要把可回收的区域都找出来, 开销大; 内存碎片
- 标记-复制(Copying)
    - 问题: 
        - 空间利用率低 -> 优化: Eden-Survivor
        - Survivor不能保证存下所有剩余对象 -> 优化: 由老年代做担保
- 标记-整理(Mark-Compact)
    - 问题:
        - STW: 该算法会与用户线程竞争空闲区域, 因此要暂停用户线程

## 3.4 HotSpot的算法细节实现

参考
- [浅析OopMap](https://blog.csdn.net/asdasd3418/article/details/77686653)
    > 在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的。 
      
    > 可以把oopMap简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在JIT编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个oopMap，就是根据safepoint把一个方法的代码分成几段，每一段代码一个oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的oopMap就会包含多条记录。  

    > 每个被JIT编译过后的方法也会在一些特定的位置记录下OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样GC在扫描栈的时候就会查询这些OopMap就知道哪里是引用了。这些特定的位置主要在： 
    > 1、循环的末尾 
    > 2、方法临返回前 / 调用方法的call指令后 
    > 3、可能抛异常的位置
    > 这种位置被称为“安全点”（safepoint）

### 3.4.1 根节点枚举 - OopMap & 安全点

OopMap
- 解决的问题: 枚举开销大, 而OopMap可以减少STW时间
- OopMap: 记录栈中哪个位置是什么类型数据, 加快枚举过程
    - 问题: 更新OopMap本身要开销, 不能一发生修改就更新

### 3.4.2 安全点
 
SafePoint: 放OopMap的地方; 可以进行GC的点
- 作用:
    - 统一在SafePoint处更新OopMap
    - 在SafePoint处执行GC
- 选取原则: 在可能发生长时间执行的地方, 如*循环结尾*, *方法返回前, call指令后*, *可能抛异常的地方*等. 
    - 为什么?:
        1. 放在这些地方, 线程可以比较频繁地"踩"到这些点上, 而不会在需要进行GC时, 要运行很久才到点上
        2. 安全点的数量又会比较少(跟方法块/循环块的数量成正比), 同时OopMap的尺寸也很小(跟方法块/循环块中的局部变量数成正比)
        3. 单个方法不会因为指令太多而长时间执行(再长也长不到哪去).

### 3.4.3 安全区域

SafePoint中断方法
- 抢占式中断: 由jvm暂停所有线程, 并让没跑到安全点的线程跑到安全点
- 主动式中断: jvm在要gc时, 设置一个标志. 线程在到达安全点时检查该标志位, 有就挂起
    - HotSpot实现: trap异常信号触发中断

SafeRegion
- SafePoint的缺点: 线程可能SLEEP/BLOCKED了
- SafeRegion原理
    - jvm在需要进行GC时设置标志, 并且不管SLEEP/BLOCKED状态的线程(已经进入了安全区)
    - SLEEP/BLOCKED状态的线程被唤醒后, 会检查标志, 并且直到GC完成才离开安全区

### 3.4.4 记忆集与卡表

记忆集: 记录非收集区域指向收集区域的指针集合
- 精度:
    - 字长精度: 某个字(32/64 bit)有指向收集区域的指针
    - 对象精度: 某个对象有指向收集区域的指针
    - 卡精度: 某个内存区域有指向收集区域的指针

卡表(卡精度): 用位数组来标识某个内存区域(card)是否有指向收集区域的指针

### 3.4.5 写屏障

写屏障: 可看作通过指令实现的针对写操作的切面
- 问题: 缓存行的伪共享. 解决方法: 只有变脏(0->1)时才去更新卡表的标志
    - -XX:+UseCondCardMark
- 作用:
    - 在写屏障中做更新卡表的操作

### 3.4.6 并发的可达性分析


并发条件下进行可达性分析的方法
- 三色标记法
    - 黑色: 扫描完成的对象
    - 灰度: 已被访问, 但对象中有引用没扫描完的对象
    - 白色: 未被扫描的对象
- 三色模型中的"消失问题"条件
    1. 在黑色对象中新增引用
    2. 在灰色对象中删除引用
- 三色标记法与并发
    - 增量更新(Incremental Update): 用户线程在黑色对象中新增引用时, 要记录下来, 在并发扫描结束后再次扫描
    - 原始快照(SATB, Snapshot At The Beginning): 用户线程在灰色对象中删除引用时, 要记录原来的指针, 在并发扫描结束后再次扫描

## 3.5 经典垃圾收集器

垃圾收集器中的并行与并发
- Parallel: 垃圾收集线程之间并发
- Concurrent: 垃圾收集线程与用户线程并发

Serial
- 客户端模式默认收集器

ParNew
- 可以与CMS配合
- 不能与Parallel Scavenge配合
- 单核时比Serial开销大

**Parallel Scavenge**: 以控制吞吐率为主, 适于对实时性有要求的场景
- 参数
    - -XX:MaxGCPauseMillis
    - -XX:GCTimeRatio: GC时间的最大比例(用户线程时间/GC时间, 如19表示5%的垃圾清理时间)
    - -XX:+UseAdaptiveSizePolicy: 自适应地调整新生代大小, Eden/Survivor大小

Serial Old: 
- 在Parralel Old出现之前与Parralel Scavenge配合
- 作为CMS失败时的备选

Parralel Old: **Parralel Scavenge的老年版**

### 3.5.6 CMS收集器

**Concurrent Mark Sweep(CMS)**执行过程: 
1. 初始标记(CMS init mark): **STW**, **快速**找到GC Roots
2. 并发标记(CMS concurrent mark): 与用户线程一起并发, 时间相对较长
3. 重新标记(CMS remark): **STW**, 重新标记一些2阶段产生的新对象, 时间较慢于1, 但远小于2
4. 并发清理(CMS concurrent sweep): 与用户线程一起并发, 执行清理


CMS的缺点
- 对CPU资源敏感
    - 增量式并发收集器(deprecated): 通过抢占式调度切换线程模拟多核
- 浮动垃圾: 重新标记可以标记新对象, 但总有漏网的新的垃圾对象. 这些无法在当次进行清理
- 要预留内存给用户线程: 预留不够时会发生并发失败, 然后冻结用户线程, 使用Serial Old
    - -XX:CMSInitiatingOccu-pancyFraction
- 内存碎片: 找不到连续空间分配大对象时容易出现Full GC
    - -XX:+UseCMSCompactAtFullCollection: CMS不得不Full GC时, 对内存碎片进行整理
    - -XX:CMSFullGCsBeforeCompaction: 多少次Full GC后进行整理

### 3.5.7 Garbage First收集器

Garbage First(G1)
- 特点:
    - 停顿时间模型: 指定在一个长度为M的时长片段内, 消耗在垃圾收集上的时间不超过N
    - Region: Region的角色不是固定的(老年代/Eden/Survivor)
        - Humongous Region: 大对象可以存储在连续的Humongous Region
    - 优先处理回收价值最大的区域(Garbage First)
- 参数:
    - -XX:G1HeapRegionSize: 1MB-32MB
    - -XX:MaxGCPauseMillis

关键问题
-跨Region引用: 每个region都用**记忆集**来记录其它Region对自己的引用
    - 记忆集结构为: `Map: region地址->Collction{卡表索引号}`, 表示region的这些卡页对自己区域对象的引用
    - **内存开销更大**
- 并发标记: 
    - 原始快照(SATB, )
    - TAMS(Top at Mark Start): 用一个指针划定一个区域, 专门在并发标记时, 用来保存新对象, 这些对象不纳入标记
        - 也会有并发失败导致Full GC
- 保证**停顿预测模型**: 衰减均值: 统计回收时间, 记忆集中脏卡数量等, 分析平均值/标准差/置信度等, 用于后续决策
    - 衰减均值: $x_t = x_{t-1} \cdot a + v_t \cdot (1 - a)$


G1收集步骤
- 初始标记: 标记一下GC Roots中能关联到的对象, 并修改一下TAMS指针. 需要停顿
    - 耗时极短, 借用Minor GC时同步完成
- 并发标记: 进行可达性分析, 耗时较长, 需要记录下SATB记录. 无需停顿.
- 最终标记: 短暂停顿, 处理原始快照(SATB)记录
- 筛选回收: 需要停顿
    1. 更新Region统计数据, 记算衰减均值, 对Region进行排序
    2. 根据用户期望的停顿时间来挑选Region组成回收集, 将存活对象复制到空Region, 然后清理掉旧Region

G1与CMS对比
- 内存占用: G1需要更多内存占用
    - 卡表: CMS只需要记录老年代到新生代的引用 
- 执行负载: G1的执行负载更高
    - G1的写屏障更复杂, 以至于需要使用类型于消息队列的方式处理SATB
- 小内存的场景下CMS效率可能更高, 大内存场景下G1更适合

//TODO 深入理解G1和CMS

## 3.7 选择合适的垃圾收集器

### 3.7.4 垃圾收集器参数总结

垃圾收集器参数总结
- Use*GC系列:
    - UseSerialGC: 客户端模式默认值, Serial + Serial Old
    - UseParNewGC: ParNew + Serial Old
    - UseConcMarkSweepGC: ParNew + CMS + Serial Old
    - UseParallelGC: Paralled Scavenge + Serial Old
    - UseParallelOldGC: Paralled Scavenge + Parallel Old
- 新老年代
    - PretenureThreshold: 提前进入老年代的大小
    - MaxTenuringThreshold: 进入老年代的年龄
    - HandlePromotionFailure: 老年代是否对Minor GC做担保
- Eden/Suvivor
    - UseAdaptiveSizePolicy: 动态调整Eden/Survivor的比例
    - SuvivorRatio: 默认为8
...
//TODO 补全

## 3.8 实战: 内存分配与回收策略

分配策略
- 优先分配在Eden, 不够空间时发生Minor GC
- 大对象直接进入老年代
    - 应避免短命大对象
- 新生代年龄记录在对象Header, 每次Minor GC都会使年龄+1
    - 尺寸大于PretenureSizeThreshold时直接进入老年代
    - 年龄大于MaxTenuringThreshold(默认15)时直接进入老年代
    - 相同年龄对象占用Suvivor大于一半时, 大于该年龄的对象进入老年代

