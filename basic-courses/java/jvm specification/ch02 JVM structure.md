* <c>// 只要按照JVM规范编写的class文件都可以在JVM上运行</c>
* <c>// 所有在JVM规范中未规定的细节, 都可以由虚拟机实现者自由发挥</c>

数据类型分类:
* 数据类型:
    * 原始类型 <-> 原始值
        * 数值类型
            * 整数类型
            * 浮点类型
        * boolean类型
        * returnAddress类型
    * 引用类型<->引用值
        * 类类型 (class type)
        * 数组类型 
        * 接口类型

* 数据类型表
    |类型|位长|范围|备注|
    |:--:|:--:|:--:|:--:|
    | **整型类型** |**\*\***|**\*\***|**\*\***|
    |byte| 8 |-128~127| - |
    |char| 16 |0~65535| UTF-8编码 |
    |int| 32 |-2^31~2^31-1| - |
    |long| 64 |-2^63~2^63-1| - |
    | **浮点类型** |**\*\***|**\*\***|**\*\***|
    | float |32 | +-Inf, +-0, NaN ||
    | double |64 | +-Inf, +-0, NaN ||
    | **boolean类型**| - |true/false|不指定实现方式|
    | **returnAddress**| ?? | - |Java中无对应数据类型, 且**运行时无法更改**|


## 2.2 数据类型
数据类型:
* 原始类型 <-> 原始值
* 引用类型<->引用值

## 2.3 原始类型与值
原始类型:
* 数值类型
    * 整数类型: byte, char, long, int
    * 浮点类型: double, long
* boolean类型
    * returnAddress类型
  
其它:
* NaN与任意值(包括NaN)进行==比较都返回false
* 0分正负是为了与正负无穷对应

### <c>//2.3.4 boolean类型
boolean:
* boolean可以通过int/byte来实现
* boolean数组由jvm直接支持, 可以通过与byte数组共用字节码来进行操作

## 2.4 引用类型
引用类型:
* 类类型
* 数组类型
    * 组件类型: 构成数据的类型
        * // 可以是原始类型, 接口类型, 类类型和数组类型的值
    * 元素类型:
        * // 可以是原始类型, 接口类型和数组类型
* 接口类型

特殊值:
* null: 起初不具备任何运行时类型, 可以转为任何类型
    * // 不规定实现

## 2.5 运行时数据区

### 2.5.1 程序计数器pc
程序计数器pc
* **线程私有**:
    * 生命周期: 与线程相同
* 保存信息:
    * 运行到非native方法时, 记录当前方法中对应的字节码指令的地址
    * 运行到native方法时, pc值为undefined
* 空间分配: 
    * 一个pc至少能容纳一个returnAddress或者与平台相关的指针的大小
    * 异常类型: 无

### 2.5.2 Java虚拟机栈
Java虚拟机栈/Java栈:
* **线程私有**:
    * 生命周期: 与线程相同
* 保存信息:
    * 栈帧: **局部变量**, **操作数帧**
* 空间分配:
    * **规范**: 用户可**初始化大小**; **动态**实现要有最大最小限制
    * 可固定, 可动态
    * 可在**运行时**或者**jvm**参数中指定
    * 异常类型:
        * OutOfMemoryException: 物理内存不够分配
        * StackOverflowException
* 特点:
    * 实现时可在堆中分配
    * 不必连续

### 2.5.3 Java堆
Java堆:
* **线程共享**:
    * 生命周期: jvm
* 保存信息:
    * 对象
* 空间分配:
    * **规范**: 可**初始化大小**, **动态**实现要有最大最小限制
    * 可固定, 可动态
    * 异常类型: OutOfMemoryException
* 不必连续

### 2.5.4 方法区
方法区:
* **线程共享**:
    * 生命周期: jvm
* 保存信息:
    * 运行时常量池
    * 类相关: 符号引用(域, 构造器, 普通方法, <init>等特殊方法), 方法字节码
* 空间分配:
    * **规范**: 用户可**初始化大小**; 动态时要有最大最小限制
    * 可固定, 可动态
    * 异常类型: OutOfMemoryException
* **可实现回收**

### 2.5.5 运行时常量池
* **类/接口私有**
* 保存信息:
    * 编译期可确定的字面值常量
    * 运行时解析的符号引用等
* 异常:
    * OutOfMemory

### 2.5.6 本地方法栈
本地方法栈:
* **线程私有**:
    * 生命周期: 线程
* 空间分配:
    * **规范**: 用户可**初始化大小**; 动态时要有最大最小限制
    * 可固定, 可扩展
    * 异常类型:
        * OutOfMemoryException
        * StackOverflowException
* 特点:
    * 可不实现

2.5 总结
* 只有栈(java栈/本地方法栈)才有StackOverflowException
* 只有pc没有异常

## 2.6 栈帧
栈帧
* 线程私有:
    * 生命周期: 方法
* 功能:
    * 动态链接
    * 处理返回结果
    * 异常分派
* 保存信息:
    * 局部变量表
    * 操作数据栈
    * 对应方法所在类的运行时常量池的指针
    * // 附加信息, 如对debug进行支持的一些信息

### 2.6.1 局部变量表
局部变量表:
* 局部变量:
    * 一个局部变量可以保存byte, char, int, float
    * long, double占两个局部变量的空间
    * 索引:
        * 局部变量的访问通过索引实现
        * long, double记录较低的索引
        * long, double不要求64位对齐
* 其它功能:
        * 参数传递: 上一栈帧传递的参数放在局部变量表的1开始的位置
            * 局部变量表的0保存当前类(this)的引用
* 容量: 编译时确定, 由class文件的code属性记录
### 2.6.2 操作数栈
操作数栈:
* 容量: **最大深度**编译时确定, 由class文件的code属性记录
* 其它功能: 调用方法时, 用来准备传递的参数; 返回后接收返回的结果
* 特点:
    * double, long占两个栈深度

### 2.6.3 动态链接
动态链接:
* 思想:
    * 通过栈帧中对当前类的**运行时常量池**的引用来获得调用方法所在类的符号引用
    * 类加载器负责解析未加载的类的符号引用
* 特点:
    * **晚期绑定**: 即使类文件发生变化, 也不会影响调用它们的参数
### 2.6.4 方法调用正常完成
正常返回:
* 返回的动作由返回指令来指定
    * 返回指令的类型与返回的数据类型有关
* 当前栈帧负责恢复上一栈帧的**局部变量表**, **操作数栈**, 将**pc**改为正确的指令地址
    * <c>// 原理思考: 程序的控制权在于当前栈帧, 只有当前栈帧能负责恢复上一栈帧的信息</c>
### 2.6.5 方法调用异常完成
略

## 2.7 对象的表示
对象的表示:
* 规范: 没有规定对象的内部表示
    * 实现之一:
    ``` json
    对象实例: {
        表格指针: {
            方法表: [
                方法1,
                方法2,
                ...
            ],
            Class实例指针: 
        },
        实例数据指针: 实例数据,
    }
    ```

## 2.8 浮点算法[**unread**]

## 2.9 特殊方法
\<init\>:
* **实例**初始化方法, 对应构造器
* 特点:
    * 方法名在Java语法中非法, 所以用户无法定义
    * 由jvm通过invokespecial调用
    * 只能在**尚未初始化**的对象中调用 (只能调用一次)

\<clinit\>:
* **类或接口**初始化方法
* 特点:
    * 方法名在Java语法中非法, 所以用户无法定义
    * 由jvm隐式调用, 没有对应的字节码
    * 在**类的初始化阶段**调用

签名多态性方法[**??**]



## 2.10 异常处理

异常出现原因:
* athrow指令
* 同步异常: **紧接在出现异常的字节码后抛出**
    * 语义错误: ArrayIndexOutOfBoundsException
    * 资源限制: OutOfMemoryException
* 异步异常: **随时抛出**
    * Thread或ThreadGroup的stop()方法
    * jvm内部错误

异常与代码优化:
* 规范: 允许出现同步异常后, 在**不改变语义**并且保证**转移控制权之前不出现其它异常**的前提下, 执行一小段代码以后再抛出异常
    * 有利于通过指令重排序优化以提高性能
    * 异常抛出位置之前的字节码指令产生的影响应当是可观察的; 指令重排序之前, 异常抛出位置之后的字节码可能提前被执行, 必须保证这些字节码对用户是不可见的

异常处理器:
* 保存信息:
    * 异常处理器作用范围: try块
    * 异常处理类型: catch(Exception e)
    * 异常处理程序
* 处理方式:
    * 抛出异常时, jvm通过异常处理器表的作用范围, 处理类型搜索可以处理异常的异常处理器
        * 找到时, 将控制权转移给异常处理代码
        * 找不到时, 弹出当前栈帧(丢弃局部变量表和操作数栈), 恢复上一栈帧, 由上一栈帧重新抛出异常
        * 到达方法调用帧顶时若仍未找到合适的异常处理器, 则**线程**终止
* 异常处理器搜索顺序
    * jvm本身不对异常处理器的顺序做干涉
    * 编译器可以适当安排异常处理器的顺序, 将顺序定义在class文件中
