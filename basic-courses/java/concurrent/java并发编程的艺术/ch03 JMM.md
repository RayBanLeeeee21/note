## 3.1 Java内存模型的基础

### 3.1.1 <c>并发编程模型的两个关键问题<c/>
同步: 控制线程间操作不同顺序的机制

线程通信: 多个线程之间如何通信
* 共享内存机制: 线程通过对共享内存的r/w来隐式通信
    * 显式同步
* 消息传递机制: 线程之间没有公共状态, 通过发送消息来显式通信
    * 隐式同步

JMM是共享内存机制
* 隐式通信
* 显式同步

### 3.1.3 <c>从源代码到指令序列的重排序<c/>

重排序类型:
1. 编译器优化的重排序 (编译器重排序): 在不改变单线程程序语义的前提下进行优化
2. 指令级并行的重排序 (处理器重排序): 对不存在依赖关系的指令并行化
3. 内存系统的重排序 (处理器重排序): 对缓冲区与内存的r/w操作做优化

JMM是**语言级**内存模型, 通过插入**内存屏障指令**来禁某些重排序, 使硬件对用户的透明, 保持JMM的一致性

### 3.1.4 <c>并发编程模型的分类<c/>

内存屏障类型表:
* LoadLoad
* StoreStore
* LoadStore
* StoreLoad

## 3.2 重排序

### 3.2.1 数据依赖性
数据依赖性: 操作涉及同一个变量, 且有一个操作为store时, 具有数据依赖性

### 3.2.2 as-if-serial语义
**as-if-serial语义**: 不管怎么重排序, 单线程程序的执行结果不能改变
* 编译器, 处理器都必须遵守as-if-serial语义

### 3.2.4 重排序对多线程的影响
重排序缓冲: 预先计算结果, 操作时直接赋值 
* e.g.: x = a\*a \<-\> temp = a*a; ... ; t = temp;

## 3.3 顺序一致性模型
### 3.3.2 顺序一致性内存模型
顺序一致性内存模型
* 特点:
    * 单一共享内存
    * 一次只有一个线程能访问内存
    * 所有操作**原子性**
    * 所有操作对其它线程立即可见
    * 每个线程内的线程都按顺序执行(不能重排序)
* **顺序一致性**: 如果程序正确同步, 则程序执行结果与顺序一致性内存模型中的执行结果一致 


## 3.7 happens-before规则
happens-before关系定义:
* 对程序员: A happens-before B, 表示A操作对B可见, 而A操作按顺序排在B操作之前
* 对编译器与处理器: A happens-before B, 则A操作不一定要在B操作之前执行, 只要保证执行结果与重排序之前一致, 那重排序就合法

happens-before规则:
* 程序顺序规则: 一个线程内的每个操作, happens-before于该线程中任意后续操作. 通过编译器和处理器遵守**as-if-serials语义**保证
* 监视器锁规则: 一个锁的unlock操作happens-before于后续的lock操作
* volatile规则: 一个volatile变量的写操作, happens-before于后续的任意volatile变量读操作
* start()规则: t1 调用t2.start(), 那t2.start()操作, happens-before于t2线程的任意操作
* join()规则: t1 调用t2.join()规则, t2线程的任意操作都happens-before于t2.join()操作成功返回
* 传递性: A happens-before B, B happens-before C, 则 A happens-before C

